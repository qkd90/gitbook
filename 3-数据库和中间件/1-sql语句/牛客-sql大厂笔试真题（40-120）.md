## **SQL42** **分析客户逾期情况**

### 描述

有贷款信息表：**loan_tb**（agreement_id：合同id，customer_id：客户id，loan_amount：贷款金额，pay_amount：已还金额，overdue_days：逾期天数）

| agreement_id | customer_id | loan_amount | pay_amount | overdue_days |
| ------------ | ----------- | ----------- | ---------- | ------------ |
| 10111        | 1111        | 20000       | 18000      | NULL         |
| 10112        | 1112        | 10000       | 10000      | NULL         |
| 10113        | 1113        | 15000       | 10000      | 38           |
| 10114        | 1114        | 50000       | 30000      | NULL         |
| 10115        | 1115        | 60000       | 50000      | NULL         |
| 10116        | 1116        | 10000       | 8000       | NULL         |
| 10117        | 1117        | 50000       | 50000      | NULL         |
| 10118        | 1118        | 25000       | 10000      | 5            |
| 10119        | 1119        | 20000       | 1000       | 106          |

客户信息表：**customer_tb**（customer_id：客户id，customer_age：客户年龄，pay_ability：还款能力级别）

| customer_id | customer_age | pay_ability |
| ----------- | ------------ | ----------- |
| 1111        | 28           | B           |
| 1112        | 38           | A           |
| 1113        | 20           | C           |
| 1114        | 30           | A           |
| 1115        | 29           | B           |
| 1116        | 21           | C           |
| 1117        | 35           | B           |
| 1118        | 36           | B           |
| 1119        | 25           | C           |

请根据以上数据分析各还款能力级别的客户逾期情况，按照还款能力级别统计有逾期行为客户占比。要求输出还款能力级别、逾期客户占比。

注：逾期客户占比要求按照百分数形式输出并四舍五入保留 1 位小数，最终结果按照占比降序排序。

示例数据结果如下：

| pay_ability | overdue_ratio |
| ----------- | ------------- |
| C           | 66.7%         |
| B           | 25.0%         |
| A           | 0.0%          |

结果解释：

还款能力级别为 C 的客户有1113、1116、1119，其中有逾期行为的客户为 1113、1119，故结果为 2/3=66.7%；其他结果同理。

### 示例1

输入：

```sql
drop table if exists  `loan_tb` ; 
CREATE TABLE `loan_tb` (
`agreement_id` int(11) NOT NULL,
`customer_id` int(11) NOT NULL,
`loan_amount` int(11) NOT NULL,
`pay_amount` int(11) NOT NULL,
`overdue_days` int(11),
PRIMARY KEY (`agreement_id`));
INSERT INTO loan_tb VALUES(10111,1111,20000,18000,null); 
INSERT INTO loan_tb VALUES(10112,1112,10000,10000,null); 
INSERT INTO loan_tb VALUES(10113,1113,15000,10000,38); 
INSERT INTO loan_tb VALUES(10114,1114,50000,30000,null); 
INSERT INTO loan_tb VALUES(10115,1115,60000,50000,null); 
INSERT INTO loan_tb VALUES(10116,1116,10000,8000,null); 
INSERT INTO loan_tb VALUES(10117,1117,50000,50000,null); 
INSERT INTO loan_tb VALUES(10118,1118,25000,10000,5); 
INSERT INTO loan_tb VALUES(10119,1119,20000,1000,106); 

drop table if exists  `customer_tb` ; 
CREATE TABLE `customer_tb` (
`customer_id` int(11) NOT NULL,
`customer_age` int(11) NOT NULL,
`pay_ability` varchar(2) NOT NULL,
PRIMARY KEY (`customer_id`));
INSERT INTO customer_tb VALUES(1111,28,'B'); 
INSERT INTO customer_tb VALUES(1112,38,'A'); 
INSERT INTO customer_tb VALUES(1113,20,'C'); 
INSERT INTO customer_tb VALUES(1114,30,'A'); 
INSERT INTO customer_tb VALUES(1115,29,'B'); 
INSERT INTO customer_tb VALUES(1116,21,'C'); 
INSERT INTO customer_tb VALUES(1117,35,'B'); 
INSERT INTO customer_tb VALUES(1118,36,'B'); 
INSERT INTO customer_tb VALUES(1119,25,'C'); 
```

输出：

```
pay_ability|overdue_ratio
C|66.7%
B|25.0%
A|0.0%
```

### 答案

```sql
SELECT ct.pay_ability,
       CONCAT(ROUND(SUM(CASE WHEN lt.overdue_days IS NOT NULL THEN 1 ELSE 0 END) / COUNT(*) * 100, 1), '%') AS overdue_ratio
FROM loan_tb lt
         join customer_tb ct ON lt.customer_id = ct.customer_id
GROUP BY ct.pay_ability
ORDER BY overdue_ratio DESC
```

## 解析

#### 计算是否总人数

```sql
SUM(CASE WHEN lt.overdue_days IS NOT NULL THEN 1 ELSE 0 END)
```

只要不是空就+1

#### 除法结果四舍五入保留一位小数

```sql
ROUND(一个数,1)
```

#### 拼接字符串

`CONCAT(...,'%')`：输出格式为‘数字’+‘%’，此处使用字符串操作，`CONCAT(A,B)`即将A字符串和B字符串连接成‘AB’字符串。



## **SQL45** **统计所有课程参加培训人次**

### 描述

某公司员工培训信息数据如下：

员工培训信息表**cultivate_tb**(info_id-信息id,staff_id-员工id,course-培训课程)，如下所示：

注：该公司共开设了三门课程，员工可自愿原则性培训0-3项，每项课程每人可培训1次。

| info_id | staff_id | course                  |
| ------- | -------- | ----------------------- |
| 101     | 1        | course1,course2         |
| 102     | 2        | course2                 |
| 103     | 3        | course1,course3         |
| 104     | 4        | course1,course2,course3 |
| 105     | 5        | course3                 |
| 106     | 6        | NULL                    |
| 107     | 7        | course1,course2         |

问题：请统计该公司所有课程参加培训人次？

示例数据结果如下：

| staff_nums |
| ---------- |
| 11         |

解释：course1课程共有员工1、3、4、7共4名员工培训；

course2课程共有员工1、2、4、7共4名员工培训；

course3课程共有员工3、4、5共3名员工培训。

### 示例1

输入：

```sql
drop table if exists  `staff_tb` ; 
CREATE TABLE `staff_tb` (
`staff_id` int(11) NOT NULL,
`staff_name` varchar(16) NOT NULL,
`staff_gender` char(8) NOT NULL,
`post` varchar(11) NOT NULL,
`department` varchar(16) NOT NULL,
PRIMARY KEY (`staff_id`));
INSERT INTO staff_tb VALUES(1,'Angus','male','Financial','dep1'); 
INSERT INTO staff_tb VALUES(2,'Cathy','female','Director','dep1'); 
INSERT INTO staff_tb VALUES(3,'Aldis','female','Director','dep2'); 
INSERT INTO staff_tb VALUES(4,'Lawson','male','Engineer','dep1'); 
INSERT INTO staff_tb VALUES(5,'Carl','male','Engineer','dep2'); 
INSERT INTO staff_tb VALUES(6,'Ben','male','Engineer','dep1'); 
INSERT INTO staff_tb VALUES(7,'Rose','female','Financial','dep2'); 

drop table if exists  `cultivate_tb` ;   
CREATE TABLE `cultivate_tb` (
`info_id` int(11) NOT NULL,
`staff_id` int(11) NOT NULL,
`course` varchar(32) NULL,
PRIMARY KEY (`info_id`));
INSERT INTO cultivate_tb VALUES(101,1,'course1,course2');
INSERT INTO cultivate_tb VALUES(102,2,'course2');
INSERT INTO cultivate_tb VALUES(103,3,'course1,course3');
INSERT INTO cultivate_tb VALUES(104,4,'course1,course2,course3');
INSERT INTO cultivate_tb VALUES(105,5,'course3');
INSERT INTO cultivate_tb VALUES(106,6,NULL);
INSERT INTO cultivate_tb VALUES(107,7,'course1,course2');
```

输出：

```
staff_nums
11
```

### 答案

```sql
select sum(num) AS staff_nums
from (
    select IF(course is null, 0, length(course) - length(replace(course, ',', '')) + 1) AS num
      from cultivate_tb) as sub

```

### 解析

#### 替换字符串操作

REPLACE(string, old_substring, new_substring)：

- `string`：原始字符串（可以是列名或字符串常量）。

- `old_substring`：要被替换的子字符串。

- `new_substring`：用来替换的新字符串。

  #### 计算字符串长度

  使用 `LENGTH()` 函数，返回**字符数**（对于多字节字符集，如 UTF-8，一个字符可能占多个字节）。

  SELECT LENGTH('Hello');        -- 结果：5 

  SELECT LENGTH('你好');         -- MySQL/PostgreSQL 中通常返回 2（字符数） 

  SELECT LENGTH('');             -- 结果：0

  那么结合以上两个函数：length(course) - length(replace(course,',','')) 计算的其实就是，的个数

## **SQL46** **查询培训指定课程的员工信息**

简单 通过率：66.71% 时间限制：1秒 空间限制：256M

### 描述

某公司员工信息数据及员工培训信息数据如下：

员工信息表**staff_tb**(staff_id-员工id，staff_name-员工姓名，staff_gender-员工性别，post-员工岗位类别，department-员工所在部门)，如下所示：

| staff_id | staff_name | staff_gender | post      | department |
| -------- | ---------- | ------------ | --------- | ---------- |
| 1        | Angus      | male         | Financial | dep1       |
| 2        | Cathy      | female       | Director  | dep1       |
| 3        | Aldis      | female       | Director  | dep2       |
| 4        | Lawson     | male         | Engineer  | dep1       |
| 5        | Carl       | male         | Engineer  | dep2       |
| 6        | Ben        | male         | Engineer  | dep1       |
| 7        | Rose       | female       | Financial | dep2       |

员工培训信息表**cultivate_tb**(info_id-信息id，staff_id-员工id，course-培训课程)，如下所示：

注：该公司共开设了三门课程，员工可自愿原则性培训0-3项；

| info_id | staff_id | course                    |
| ------- | -------- | ------------------------- |
| 101     | 1        | course1, course2          |
| 102     | 2        | course2                   |
| 103     | 3        | course1, course3          |
| 104     | 4        | course1, course2, course3 |
| 105     | 5        | course3                   |
| 106     | 6        | NULL                      |
| 107     | 7        | course1, course2          |

问题：请查询培训课程course3的员工信息？

注：只要培训的课程中包含course3课程就计入结果

要求输出：员工id、姓名，按照员工id升序排序；
示例数据结果如下：

| staff_id | staff_name |
| -------- | ---------- |
| 3        | Aldis      |
| 4        | Lawson     |
| 5        | Carl       |

解释：有员工3、4、5培训了course3课程，故结果如上

### 示例1

```sql
drop table if exists  `staff_tb` ; 
CREATE TABLE `staff_tb` (
`staff_id` int(11) NOT NULL,
`staff_name` varchar(16) NOT NULL,
`staff_gender` char(8) NOT NULL,
`post` varchar(11) NOT NULL,
`department` varchar(16) NOT NULL,
PRIMARY KEY (`staff_id`));
INSERT INTO staff_tb VALUES(1,'Angus','male','Financial','dep1'); 
INSERT INTO staff_tb VALUES(2,'Cathy','female','Director','dep1'); 
INSERT INTO staff_tb VALUES(3,'Aldis','female','Director','dep2'); 
INSERT INTO staff_tb VALUES(4,'Lawson','male','Engineer','dep1'); 
INSERT INTO staff_tb VALUES(5,'Carl','male','Engineer','dep2'); 
INSERT INTO staff_tb VALUES(6,'Ben','male','Engineer','dep1'); 
INSERT INTO staff_tb VALUES(7,'Rose','female','Financial','dep2'); 

drop table if exists  `cultivate_tb` ;   
CREATE TABLE `cultivate_tb` (
`info_id` int(11) NOT NULL,
`staff_id` int(11) NOT NULL,
`course` varchar(32) NULL,
PRIMARY KEY (`info_id`));
INSERT INTO cultivate_tb VALUES(101,1,'course1,course2');
INSERT INTO cultivate_tb VALUES(102,2,'course2');
INSERT INTO cultivate_tb VALUES(103,3,'course1,course3');
INSERT INTO cultivate_tb VALUES(104,4,'course1,course2,course3');
INSERT INTO cultivate_tb VALUES(105,5,'course3');
INSERT INTO cultivate_tb VALUES(106,6,NULL);
INSERT INTO cultivate_tb VALUES(107,7,'course1,course2');
```

### 答案

```sql
select c.staff_id,
       s.staff_name
from cultivate_tb c
         left join staff_tb s on c.staff_id = s.staff_id
where c.course like '%course3%'
order by c.staff_id;
```

### 解析

#### 常用正则表达式语法

不同数据库支持的正则表达式语法略有差异，以下是常见模式：

- ^：匹配字符串开头。
- $：匹配字符串结尾。
- .：匹配任意单个字符。
- *：匹配前面的字符 0 次或多次。
- +：匹配前面的字符 1 次或多次。
- []：匹配括号内的任意单个字符（如 [a-z] 匹配小写字母）。
- |：表示“或”，匹配左右任一模式。
- \d：匹配数字（部分数据库需用 [0-9]）。
- \w：匹配字母、数字或下划线（部分数据库需用 [a-zA-Z0-9_]）。

数据库中正则表达式的使用

#### MySQL 正则表达式

使用 REGEXP 运算符进行正则匹配。

```sql
SELECT * FROM table_name WHERE column_name REGEXP 'course[0-9]';
```

- 示例：查询字段 column_name 中包含 "course" 后跟一个数字的记录。
- 常见模式：
  - ^course：匹配以 "course" 开头的字符串。
  - [0-9]+：匹配一个或多个数字。
  - course$：匹配以 "course" 结尾的字符串。

## 